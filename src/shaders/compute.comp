#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;


#define MAX_DEPTH 80.0
#define MIN_CULL_DEPTH 30.0
#define DEPTH_BUCKETS 5

const int NUM_BLADES = 1 << 13;

layout(set = 0, binding = 0) uniform CameraBufferObject {
    mat4 view;
    mat4 proj;
    vec4 forward;
    vec4 position;
} camera;

layout(set = 1, binding = 0) uniform Time {
    float deltaTime;
    float totalTime;
};

struct Blade {
    vec4 v0;
    vec4 v1;
    vec4 v2;
    vec4 up;
};

layout(set = 2, binding = 0) buffer BladesBuffer {
    Blade blades[NUM_BLADES];
};

layout(set = 2, binding = 1) buffer CulledBladesBuffer {
    Blade culled_blades[NUM_BLADES];
};

layout(set = 2, binding = 2) buffer NumBlades {
	  uint vertexCount;   // Write the number of blades remaining here
	  uint instanceCount; // = 1
	  uint firstVertex;   // = 0
	  uint firstInstance; // = 0
} numBlades;

layout(set = 2, binding = 3) buffer BladeStateBuffer {
    vec4 blade_state[NUM_BLADES];
};

bool inBounds(float value, float bounds) {
    return (value >= -bounds) && (value <= bounds);
}

bool check_point_in_frustum(vec3 p) {
    vec4 clip_pos = camera.proj * camera.view * vec4(p, 1.0);
    float tolerance = 0.1; 
    return inBounds(clip_pos.x, clip_pos.w + tolerance) && 
           inBounds(clip_pos.y, clip_pos.w + tolerance) && 
           (clip_pos.z >= -tolerance && clip_pos.z <= clip_pos.w + tolerance);
}

float noise(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}


const vec3 GRAVITY_DIR = vec3(0.0, -1.0, 0.0);
const float GRAVITY_ACCELERATION = 1.0;

void main() {
    if (gl_GlobalInvocationID.x == 0) {
        numBlades.vertexCount = 0;
    }
    barrier(); 

    Blade blade = blades[gl_GlobalInvocationID.x];
    vec3 v0 = blade.v0.xyz;
    vec3 up = blade.up.xyz;
    float h = blade.v1.w; 
    float s = blade.up.w * 0.25;
    float orientation = blade.v0.w;

    vec4 state = blade_state[gl_GlobalInvocationID.x];
    vec3 v2 = state.xyz; 
    float eta = state.w; 

    float a = 0.5;
    eta = max(eta - a * deltaTime, 0.0);

    vec3 iv2 = v0 + up * h; 
    vec3 r = (iv2 - v2) * s * max(1.0 - eta, 0.1);

    vec3 gE = GRAVITY_DIR * GRAVITY_ACCELERATION;
    vec3 sideDir = normalize(vec3(sin(orientation), 0, cos(orientation)));
    vec3 front = normalize(cross(up, sideDir)); 
    vec3 gF = 0.25 * length(gE) * front;
    vec3 g = gE + gF;

    vec3 wi = vec3(sin(totalTime + v0.x * 0.1), 0, cos(totalTime + v0.z * 0.1)); 
    float fd = 1.0 - abs(dot(normalize(wi), normalize(v2 - v0))); 
    float fr = dot(v2 - v0, up) / h;  
    vec3 w = wi * fd * fr;

    v2 += (r + g + w) * deltaTime;

    v2 -= up * min(dot(up, v2 - v0), 0.0);

    float l_proj = length(v2 - v0 - up * dot(v2 - v0, up));
    vec3 v1 = v0 + h * up * max(1.0 - l_proj / h, 0.05 * max(l_proj / h, 1.0));

    float L0 = distance(v0, v2);
    float L1 = distance(v0, v1) + distance(v1, v2);
    float L = (2.0 * L0 + (3.0 - 1.0) * L1) / (3.0 + 1.0); 

    float ratio = h / L;
    vec3 v1_corr = v0 + ratio * (v1 - v0);
    vec3 v2_corr = v1_corr + ratio * (v2 - v1);

    blade.v1.xyz = v1_corr;
    blade.v2.xyz = v2_corr;
    blade_state[gl_GlobalInvocationID.x] = vec4(v2_corr, eta);

    barrier();




    // blade.v2.xyz += vec3(sin(totalTime), 0.0, 0.0);
    // float orientation = 3.14159 / 4.0;
    vec3 bitangent = normalize(vec3(sin(orientation), 0, cos(orientation)));

    vec3 dist = (blade.v0.xyz - camera.position.xyz);
    vec3 view = normalize(vec3(dist.x, 0.0, dist.z));

    // orientation culling
    if (abs(dot(normalize(bitangent), view)) > 0.98) {
        return;
    }

    
    // frustum culling
    vec3 m = 0.25 * blade.v0.xyz + 0.5 * blade.v1.xyz + 0.25 * blade.v2.xyz;

    if (!check_point_in_frustum(blade.v0.xyz) && !check_point_in_frustum(blade.v2.xyz) && !check_point_in_frustum(m)) {
        return;
    }


    // depth culling
    float depth = length(dist);
    if (depth > MAX_DEPTH) {
        return;
    }

    if (depth > MIN_CULL_DEPTH) {
        float depth_bucket_width = (MAX_DEPTH - MIN_CULL_DEPTH) / float(DEPTH_BUCKETS);
        int depth_bucket = int((depth - float(MIN_CULL_DEPTH)) / depth_bucket_width);
        float rand = noise(blade.v0.xz);
        float threshold = 1.0 - (depth_bucket * 0.15);

        if (rand > threshold) {
            return;
        }
    }

	// TODO: Cull blades that are too far away or not in the camera frustum and write them
	// to the culled blades buffer
	// Note: to do this, you will need to use an atomic operation to read and update numBlades.vertexCount
	// You want to write the visible blades to the buffer without write conflicts between threads
    uint idx = atomicAdd(numBlades.vertexCount, 1);
    culled_blades[idx] = blade;
}
